## object copy by reference

- 객체는 참조에 의해 저장되고 복사된다. primitive type은 값 그대로 저장, 할당, 복사 된다.

- 객체를 변수에 할당할 때는 객체가 그대로 저장되는 것이 아니다. 객체가 저장되어있는 '메모리 주소'인 객체에 대한 '참조 값'이 할당된다. 즉, 객체가 할당된 변수를 복사하면 객체를 복사하는 것이 아닌 '참조 값'을 복사하게 된다. 각 변수가 하나의 객체를 참조하고 있으므로 하나의 변수를 통해 객체의 프로퍼티 값을 수정하면 다른 변수에서 해당 프로퍼티 값을 조회했을 때 수정된 프로퍼티 값이 출력되게 된다.

- 동일한 객체를 참조하는 두 변수를 equality operator '=='와 strict equality operator '==='를 이용해 비교하면 모두 true가 반환된다. 비어 있는 객체를 두 변수에 각각 생성하여 할당할 경우 두 변수에 할당된 객체 모두 비어있는 객체라는 점에서 같아보이지만 서로 다른 메모리 주소에 저장된 독립된 객체이다. '=='와 '==='를 사용하여 비교할 경우 둘 다 false가 반환된다.

- 객체끼리의 대소 비교나 객체와 primitive type과의 비교에서는 객체가 primitive type으로 변환된다.

- 객체를 복제하기 위해서는 새로운 객체를 만든 다음 기존 객체의 프로퍼티들을 순회해 원시 수준까지 프로퍼티를 복사하면 된다. 'Object.assign(인수, 인수...)'를 사용할 수도 있다. 첫 번째 인수에는 복제의 대상이 되는 객체를 전달하고 이후의 인수부터는 첫 번째 인수에 더할 객체들을 전달하여 사용한다. 첫 번째 인수의 객체에 다른 객체들의 프로퍼티가 더해져 반환된다. 동일한 프로퍼티 이름이 있는 경우에는 덮어씌워진다.

- 중첩 객체인 경우에는 객체 프로퍼티의 각 값을 검사하면서 값이 객체인 경우 객체의 구조도 복사해주는 반복문을 사용해야 한다. 이런 방식을 'deep cloning(깊은 복사)'라고 한다. Structured cloning algorithm은 deep cloning시 사용되는 표준 알고리즘이다. 'lodash' 라이브러리의 '_.cloneDeep(인수)'을 사용하면 Strucutred cloning algorithm을 구현하지 않고도 깊은 복사를 처리할 수 있다.

### 참조
---

- [모던 JavaScript 튜토리얼 - 4.2 참조에 의한 객체 복사](https://ko.javascript.info/object-copy)